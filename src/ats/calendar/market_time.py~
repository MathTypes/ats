import datetime
import functools
import logging

import pandas_market_calendars as mcal
import pytz

@functools.lru_cache(maxsize=None)
def get_open_time(cal, x_date):
    schedule = cal.schedule(start_date=x_date, end_date=x_date+datetime.timedelta(days=5))
    return schedule.market_open[0].timestamp()

@functools.lru_cache(maxsize=None)
def get_close_time(cal, x_date):
    schedule = cal.schedule(start_date=x_date, end_date=x_date+datetime.timedelta(days=5))
    return schedule.market_close[0].timestamp()

def utc_to_nyse_time(utc_time, interval_minutes):
    utc_time = time_util.round_up(utc_time, interval_minutes)
    nyc_time = pytz.timezone('America/New_York').localize(
        datetime.datetime(utc_time.year, utc_time.month, utc_time.day,
                          utc_time.hour, utc_time.minute))
    # Do not use following.
    # See https://stackoverflow.com/questions/18541051/datetime-and-timezone-conversion-with-pytz-mind-blowing-behaviour
    # why datetime(..., tzinfo) does not work.
    #nyc_time = datetime.datetime(utc_time.year, utc_time.month, utc_time.day,
    #                             utc_time.hour, utc_time.minute,
    #                             tzinfo=pytz.timezone('America/New_York'))
    return nyc_time

def compute_open_time(x, cal):
    #logging.info(f"x:{x}, {type(x)}")
    try:
        x = datetime.datetime.fromtimestamp(x)
        return int(get_open_time(cal, x.date()))
    except Exception as e:
        logging.info(f"can not compute open for {x}, {e}")
        return x

def compute_close_time(x, cal):
    # logging.info(f"x:{x}, {type(x)}")
    try:
        x = datetime.datetime.fromtimestamp(x)
        return int(get_close_time(cal, x.date()))
    except Exception as e:
        logging.info(f"can not compute open for {x}, {e}")
        return x

def compute_next_open_time(x, cal):
    try:
        x = datetime.datetime.fromtimestamp(x)
        x_date = x.date() + time.timedelta(days=1)
        return int(get_close_time(cal, x_date))
    except Exception as e:
        logging.info(f"can not compute open for {x}, {e}")
        return x

def get_next_trading_time(cal, now, k):
    start_date = now.date()
    schedule = self.market_cal.schedule(start_date=start_date, end_date=start_date+timedelta(days=5))
        test_dates = self.market_cal.valid_days(
            start_date=self.test_start_date, end_date=self.test_end_date
        )
        train_dataset = self.data_module.training
        train_data = self.data_module.train_data
        future_data = self.data_module.test_data

        logging.info(f"train_data:{train_data.iloc[-2:]}")
        logging.info(f"future_data:{future_data.iloc[:2]}")
        wandb_logger = WandbLogger(project="ATS", log_model=True)
        last_time_idx = train_data.iloc[-1]["time_idx"]
        last_data_time = None
        position_map = {}
        prediction_map = {}
        last_position_map = {} 
        last_px_map = {}
        last_data = train_data.iloc[-1]
        logging.info(f"last_data:{last_data}")
        last_px_map[last_data.ticker] = last_data.close
        logging.info(f"initial_last_px_map:{last_px_map}")
        last_position_map = defaultdict(lambda:0,last_position_map)
        pnl_df = pd.DataFrame(columns = ["ticker","timestamp","px","last_px","pos","pnl"])
        max_prediction_length = self.config.model.prediction_length
        for test_date in test_dates:
            schedule = self.market_cal.schedule(
                start_date=test_date, end_date=test_date
            )
            logging.info(f"sod {test_date}")
            time_range = mcal.date_range(schedule, frequency="30M")
    for utc_time in time_range:
        nyc_time = utc_time.astimezone(pytz.timezone("America/New_York"))

